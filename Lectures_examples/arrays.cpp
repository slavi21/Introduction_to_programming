#include <iostream>

void arrayExamples(){
    int a[10] = {1, 5, 4, 3, 7, 9};
    int b[10] = {2, 4, 6, 3, 8, 10};

    std::cout<< a[1]<< '\n';// извежда първия елемент на масива

    //!!! a = b 
    // не можем да присвояваме един масив ана друг само с "="
    // трябва да го направим с цикъл
    
    std::cout << std::boolalpha << (a == b) << std::endl;// false(0)
    std::cout << std::boolalpha << (a == a) << std::endl;// true(1)

    //std::cin >> a; не можем да правим това, ако искаме да въведем елементите на масив трябва да го направим с цикъл 
    // няма операция за вход и изход на масива
    int * pointerToTheFirstElement;
    pointerToTheFirstElement = &a[1];
    std::cout<< pointerToTheFirstElement<< '\n';
    std::cout<< a; // ще изведе адреса на първия елемент на масива
}

int main() 
{
    const int ARRAY_SIZE = 100;
    int a[ARRAY_SIZE];
    int n;

    do{
        std::cout<<"Enter number of elements: ";
        std::cin>>n;
    }while(n <= 0 || n > ARRAY_SIZE);// случаите които са невъзможни, въвеждаме число докато не е такова отговарящо на допустимите рамки

    // 1) въвеждане на елементите на масива
    for(int i = 0; i < n; ++i) {
        std::cout<< "a["<< i <<"] = ";
        std::cin>> a[i];
    }

    // 2) извеждане на елементите на масив
    for (int i = 0; i < n; ++i) {
        std::cout<< "a["<< i <<"] = "<< a[i]<< '\n';
    }

    // 3) Сума на числата в даден масива
    int sum = 0;
    for(int i = 0; i < n; ++i) {
        sum = sum + a[i];

    }
    std::cout<< "The sum of the array elements is:"<< sum << '\n';

    // 4) Да се провери дали дадено число се среща в масив
    // задача за същестуване => подходящия цикъл в случая е while и след няго условие
    int desiredNumber;
    std::cout<<"Enter the number you want to see if it's occur in the array: \n";
    std::cin>> desiredNumber;
    
    // for loop не е особено подходящ в цикъла, трябва да ползваме break в if проверката, защото ако имаме повече от едно срещане на числото 
    // ще получим съобщението за наличе на търсеното число няколко пъти
    // for loop e по-подходящ за задачи с условие За Всяко, а не такива за Същестува 
     for(int i; i < n; ++i) {
        if(a[i] == desiredNumber) {
            std::cout<<"The desired number occurs in the array \n";
            break;
        }
    }                     
    
    // 2-ри начин

    // добър вариант (да): a[i] = desiredNumber;
    // лош вариант (не): i >= n;
    // въртим цикъла докато тези условия не са изпълнени => докато не намерим желаното число и не излезем от рамките на масива, ако се случи едно от двете цикъла приключва

    int i = 0; 
    // Винаги правим проверката за коректност на индекса първа, защото да речем можем да имаме i = 100, 
    // ако n съвпада с размера ARRAY_SIZE, ще имаме a[100], a такъв елемент няма защото масива се индексира от 0 
    // и така ще се опитаме да достъпим на практика невалидна памет, което може да доведе до segmentation fault
    // Операторът && в C (логическо И) използва късо съединение (short-circuit evaluation). 
    //Това означава, че ако първото условие е лъжа, второто въобще няма да бъде проверено.
    // n == ARRAY_SIZE, desiredNumber не се среща в масива, i == n, a[100]???
    while(i < n && a[i] != desiredNumber) { 
          // инвариант: desiredNumber не е равно на нито едно от a[0], a[1], a[2], ..., a[i]
        i++;
    }
    if(i == n){
    std::cout<<"The desired number does NOT occur in the array\n";
    } else {
    std::cout<< "The desired number "<< desiredNumber << " occurs in the array\n";
    }
    

    // 5) Да се провери дали числата в масива нарастват монотонно
    // изглежда като задача за всяко, но всъщност е задача за съществуване и по-точно това е отрицание на задача за съществуване
    // искаме да няма i, така че a[i] > a[i + 1]
    //=> използваме while
    // проверяваме дали няма нарушение на намаляващата монотонност

    // добър вариант: i == n - 1 (няма нарушение)
    // лош вариант: а[i] > a[i + 1] (има нарушение)

    i = 0;

    while(i < n-1 && a[i] <= a[i + 1])
    {
        i++;
    }
    
    if(i < n - 1) {
       std::cout<<"The array of elements is not monotonically increasing \n";
    }
    else{
        std::cout<<"The array of elements is monotonically increasing \n";
    }
    


    // 6) Да се провери дали всички числа в даден масив са различни
    // няма такова i за което да има такова j за което а[i] == a[j] => задача за съществува
    // или за всяко i != j a[i] != a[j]
    // трябва да обходим всички двойки елементи, тоест започваме от a[0] = i и проверяваме за всички останали елементи, след това итерираме i и правим същото
    // външния цикъл ще е по i, вътрешния по j 

    // добър вариант: i == n-1, по-добре е да проверим дали j == n // когато и дойде на последния елемент, няма повече j, няма какво повече да проверява
    // лош вариант: a[i] == a[j]

    i = 0;
    int j = 1;
    while(i < n -1) {
        // сега трябва да проверим дали a[i] се среща в масива
        // от a[i + 1] нататък, т.е отново имаме задачата дали едно число се среща в масив
        j = i + 1;
        while(j < n && a[i] != a[j]){
            // инвариант: a[i] не е равно на нито едно от a[0], a[1], ..., a[j]
            j++;
        }
        //if(j == n) 
        // не сме намерили съвпадение на а[i] и a[j] и трябва да продължим търсенето
        if (j < n) {
        // намерили сме съвпадение: няма нужда да проверяваме следващите i
        // прекъсваме външния цикъл, без break — използваме условие
        i = n; // това ще спре външния while
        } else {
        // не сме намерили съвпадение за текущото i
        i++;
        }
    
    }

    if(j == n){
        std::cout<<"The elements in the array are diffrent \n";

    } else{ 
        std::cout<<"The array has repeating elements \n ";
    }

    // Втори начин

    i = 0;
    j = 1;
    while (i < n - 1) {
    j = i + 1; // започваме да сравняваме със следващия
    while (j < n && a[i] != a[j]) {
        j++;
    }
    if (j < n) {
        // намерено повторение
        break;
    }
    i++;
}

    if (i == n - 1) {
    std::cout << "The elements in the array are different\n";
    } else {
    std::cout << "The array has repeating elements\n";
    }



    arrayExamples();

    return 0;

}
    
